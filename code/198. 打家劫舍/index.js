/**
 * @param {number[]} nums
 * @return {number}
 */
// 这个题目要考虑到：1.并不是完全按照隔一个打劫一个，因为有时候隔两个打劫更划算，比如 [1, 2, 3, 1]
//  因为第n个房子的偷与不偷是需要抉择的，偷的话只能以前n-2个房子被偷的总金额加上自己，不偷的话能得到的就是前n-1个房子被偷的总金额，这两个结果得到的大小不确定。比如是否要偷第4个金额为1的房子？如果偷，那么只能是前两个房子(当然这两个并不是说肯定都被偷)被偷的金额加上自己，如果不偷，那么就是前三个房子被偷的总金额。后面被偷的所有房子都是这个规律，说明什么？说明偷每个房子都遇到的是一个同样的问题，也就符合"动态规划"的思路。
var rob = function (nums) {
  if (nums.length === 0) return 0;
  let n_2 = 0, n_1 = nums[0];    // n_2和n_1分别表示偷前n-2和n-1个房子得到的总金额。
  for (let i = 2; i <= nums.length; i++) {      // 房子的数量从2开始
    const max = Math.max(n_2 + nums[i - 1], n_1);   // max表示偷/不偷间得到的最大总金额
    n_2 = n_1;      // 往后推移，这个房子过后,n_2和n_1都向后走一位，因此各自得到自己的金额
    n_1 = max;
  }
  return n_1;
};

const nums = [2, 1, 1, 5]
console.log(rob(nums));